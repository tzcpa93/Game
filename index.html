<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Office Runner - AOL Man Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #333;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            background-color: #87CEEB; /* Sky blue */
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .ui-panel {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        
        #score-display {
            top: 10px;
            left: 10px;
            font-size: 16px;
        }
        
        #timer-display {
            top: 10px;
            right: 10px;
            font-size: 16px;
        }
        
        #checkpoint-message {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            background-color: rgba(30, 144, 255, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 20;
            color: white;
            text-align: center;
            padding-top: 100px;
        }
        
        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #game-over p {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        #game-start {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 30;
            color: white;
            text-align: center;
            padding-top: 80px;
        }
        
        #game-start h1 {
            font-size: 40px;
            margin-bottom: 20px;
            color: #ffcc00;
        }
        
        #game-start p {
            font-size: 18px;
            margin-bottom: 15px;
        }
        
        .button {
            background-color: #ffcc00;
            color: #333;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            margin: 10px;
            transition: background-color 0.3s, transform 0.1s;
            display: inline-block;
            pointer-events: auto;
        }
        
        .button:hover {
            background-color: #ffd700;
            transform: scale(1.05);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        #leaderboard {
            display: none;
            width: 80%;
            max-height: 200px;
            margin: 20px auto;
            overflow-y: auto;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
        }
        
        #leaderboard table {
            width: 100%;
            border-collapse: collapse;
        }
        
        #leaderboard th, #leaderboard td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #leaderboard th {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        #player-name-input {
            padding: 8px;
            margin: 10px;
            width: 250px;
            font-size: 16px;
        }
        
        @keyframes dust {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(2); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-layer">
            <div id="score-display" class="ui-panel">Score: 0</div>
            <div id="timer-display" class="ui-panel">Time: 0:00</div>
            <div id="checkpoint-message" class="ui-panel"></div>
            
            <div id="game-start">
                <h1>Office Runner</h1>
                <p>Help the AOL Man navigate through the office obstacles!</p>
                <div>
                    <p><strong>Controls:</strong></p>
                    <p>Left/Right Arrow: Move</p>
                    <p>Up Arrow: Jump</p>
                    <p>Spacebar: Shoot Fireball</p>
                </div>
                <button id="start-button" class="button">Start Game</button>
            </div>
            
            <div id="game-over">
                <h2>Game Over!</h2>
                <p id="final-score">Your Score: 0</p>
                <p id="final-time">Completion Time: 0:00</p>
                <div>
                    <input type="text" id="player-name-input" placeholder="Enter your name" maxlength="15">
                    <button id="save-score-button" class="button">Save Score</button>
                </div>
                <div id="leaderboard">
                    <h3>Top Scores</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Name</th>
                                <th>Score</th>
                                <th>Time</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody id="leaderboard-body">
                        </tbody>
                    </table>
                </div>
                <button id="share-button" class="button">Share Score</button>
                <button id="restart-button" class="button">Play Again</button>
            </div>
        </div>
    </div>
    
    <script>
        // Main Game Class
        class Game {
            constructor() {
                // Canvas and context setup
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 800;
                this.canvas.height = 500;
                
                // Game state
                this.isRunning = false;
                this.gameOver = false;
                this.victory = false;
                this.score = 0;
                this.startTime = 0;
                this.currentTime = 0;
                this.timeElapsed = 0;
                
                // Camera
                this.camera = {
                    x: 0,
                    y: 0,
                    width: this.canvas.width,
                    height: this.canvas.height
                };
                
                // Level
                this.levelWidth = 4000; // Total level width
                this.checkpoints = [
                    { x: 1000, passed: false, message: "Checkpoint 1! Great start!" },
                    { x: 2500, passed: false, message: "Checkpoint 2! Keep going!" },
                    { x: 3500, passed: false, message: "Final stretch! You can do it!" }
                ];
                this.flagpole = { x: 3800, y: 300, width: 20, height: 200 };
                
                // Create player
                this.player = new Player(this);
                
                // Create platforms
                this.platforms = [];
                this.createPlatforms();
                
                // Create monsters
                this.monsters = [];
                this.createMonsters();
                
                // Fireball array
                this.fireballs = [];
                
                // Input handling
                this.keys = {};
                this.lastFireballTime = 0;
                
                // UI elements
                this.scoreDisplay = document.getElementById('score-display');
                this.timerDisplay = document.getElementById('timer-display');
                this.checkpointMessage = document.getElementById('checkpoint-message');
                this.gameOverScreen = document.getElementById('game-over');
                this.gameStartScreen = document.getElementById('game-start');
                this.finalScoreDisplay = document.getElementById('final-score');
                this.finalTimeDisplay = document.getElementById('final-time');
                this.leaderboard = document.getElementById('leaderboard');
                
                // Setup input listeners
                this.setupEventListeners();
                
                // Animation frame ID
                this.animationFrameId = null;
                
                // BOI monster respawn
                this.boiRespawnTimer = 0;
                this.shouldRespawnBoi = false;
                
                // Initialize the game
                this.init();
            }
            
            init() {
                // Setup button listeners
                document.getElementById('start-button').addEventListener('click', () => {
                    this.startGame();
                });
                
                document.getElementById('restart-button').addEventListener('click', () => {
                    this.resetGame();
                    this.startGame();
                });
                
                document.getElementById('save-score-button').addEventListener('click', () => {
                    this.saveScore();
                });
                
                document.getElementById('share-button').addEventListener('click', () => {
                    this.shareScore();
                });
                
                // Load leaderboard
                this.loadLeaderboard();
            }
            
            startGame() {
                this.gameStartScreen.style.display = 'none';
                this.isRunning = true;
                this.startTime = Date.now();
                this.gameLoop();
            }
            
            resetGame() {
                // Reset game state
                this.score = 0;
                this.gameOver = false;
                this.victory = false;
                this.timeElapsed = 0;
                
                // Reset player
                this.player = new Player(this);
                
                // Reset camera
                this.camera.x = 0;
                
                // Reset checkpoints
                this.checkpoints.forEach(checkpoint => {
                    checkpoint.passed = false;
                });
                
                // Reset monsters
                this.monsters = [];
                this.createMonsters();
                
                // Reset fireballs
                this.fireballs = [];
                
                // Reset BOI respawn
                this.boiRespawnTimer = 0;
                this.shouldRespawnBoi = false;
                
                // Reset UI
                this.gameOverScreen.style.display = 'none';
                this.scoreDisplay.textContent = `Score: ${this.score}`;
                this.timerDisplay.textContent = `Time: 0:00`;
            }
            
            gameLoop() {
                if (!this.isRunning) return;
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Update time
                this.currentTime = Date.now();
                this.timeElapsed = (this.currentTime - this.startTime) / 1000;
                
                // Update game objects
                this.update();
                
                // Render game objects
                this.render();
                
                // Update UI
                this.updateUI();
                
                // Continue game loop
                this.animationFrameId = requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                // Update player
                this.player.update();
                
                // Update camera to follow player
                this.updateCamera();
                
                // Update monsters
                this.updateMonsters();
                
                // Update fireballs
                this.updateFireballs();
                
                // Check for BOI respawn
                this.checkBoiRespawn();
                
                // Check checkpoint collisions
                this.checkCheckpoints();
                
                // Check flagpole collision
                this.checkFlagpole();
            }
            
            render() {
                // Draw background
                this.drawBackground();
                
                // Draw platforms
                this.renderPlatforms();
                
                // Draw checkpoints
                this.renderCheckpoints();
                
                // Draw flagpole
                this.renderFlagpole();
                
                // Draw monsters
                this.renderMonsters();
                
                // Draw player
                this.player.render();
                
                // Draw fireballs
                this.renderFireballs();
            }
            
            updateCamera() {
                // Camera follows player horizontally
                const targetX = this.player.x - this.canvas.width / 3;
                
                // Smooth camera movement
                this.camera.x += (targetX - this.camera.x) * 0.1;
                
                // Clamp camera to level boundaries
                this.camera.x = Math.max(0, Math.min(this.camera.x, this.levelWidth - this.canvas.width));
            }
            
            createPlatforms() {
                // Ground platform
                this.platforms.push({
                    x: 0,
                    y: 450,
                    width: this.levelWidth,
                    height: 50,
                    type: 'ground'
                });
                
                // Checkpoint 1 area - Easy platforms
                this.platforms.push(
                    { x: 200, y: 380, width: 100, height: 20, type: 'desk' },
                    { x: 350, y: 320, width: 150, height: 20, type: 'desk' },
                    { x: 550, y: 370, width: 120, height: 20, type: 'desk' },
                    { x: 750, y: 300, width: 100, height: 20, type: 'desk' },
                    { x: 900, y: 250, width: 150, height: 20, type: 'desk' }
                );
                
                // Checkpoint 2 area - Medium platforms
                this.platforms.push(
                    { x: 1200, y: 380, width: 80, height: 20, type: 'desk' },
                    { x: 1350, y: 320, width: 120, height: 20, type: 'desk' },
                    { x: 1550, y: 380, width: 80, height: 20, type: 'desk' },
                    { x: 1700, y: 280, width: 100, height: 20, type: 'desk' },
                    { x: 1880, y: 350, width: 140, height: 20, type: 'cabinet' },
                    { x: 2100, y: 300, width: 70, height: 20, type: 'cabinet' },
                    { x: 2250, y: 250, width: 120, height: 20, type: 'cabinet' }
                );
                
                // Checkpoint 3 area - Hard platforms
                this.platforms.push(
                    { x: 2600, y: 380, width: 60, height: 20, type: 'cabinet' },
                    { x: 2700, y: 320, width: 80, height: 20, type: 'cabinet' },
                    { x: 2850, y: 380, width: 60, height: 20, type: 'cabinet' },
                    { x: 2950, y: 300, width: 70, height: 20, type: 'cabinet' },
                    { x: 3100, y: 250, width: 60, height: 20, type: 'cabinet' },
                    { x: 3250, y: 320, width: 70, height: 20, type: 'cabinet' },
                    { x: 3400, y: 260, width: 60, height: 20, type: 'cabinet' },
                    { x: 3600, y: 380, width: 300, height: 20, type: 'desk' }
                );
            }
            
            createMonsters() {
                // Checkpoint 1 area - Easy monsters
                this.monsters.push(
                    new Monster(this, 400, 290, 'DOGE'),
                    new Monster(this, 650, 340, 'Paper'),
                    new Monster(this, 950, 220, 'Client')
                );
                
                // Checkpoint 2 area - Medium monsters
                this.monsters.push(
                    new Monster(this, 1400, 290, 'DOGE'),
                    new Monster(this, 1600, 350, 'Paper'),
                    new Monster(this, 1750, 250, 'Client'),
                    new Monster(this, 1950, 320, 'Mercedes'),
                    new Monster(this, 2200, 270, 'Paper')
                );
                
                // Checkpoint 3 area - Hard monsters
                this.monsters.push(
                    new Monster(this, 2650, 350, 'Mercedes'),
                    new Monster(this, 2750, 290, 'DOGE'),
                    new Monster(this, 2900, 350, 'Client'),
                    new Monster(this, 3000, 270, 'Paper'),
                    new Monster(this, 3150, 220, 'Mercedes'),
                    new Monster(this, 3300, 290, 'BOI'),
                    new Monster(this, 3450, 230, 'DOGE')
                );
            }
            
            updateMonsters() {
                for (let i = this.monsters.length - 1; i >= 0; i--) {
                    const monster = this.monsters[i];
                    monster.update();
                    
                    // Check collision with player
                    if (this.collides(this.player, monster)) {
                        // If player is falling onto monster
                        if (this.player.velocityY > 0 && this.player.y + this.player.height < monster.y + monster.height / 2) {
                            // Player defeats monster by jumping on it
                            this.score += 100;
                            this.createDustEffect(monster.x, monster.y);
                            
                            // Check if this is the BOI monster
                            if (monster.type === 'BOI') {
                                this.shouldRespawnBoi = true;
                                this.boiRespawnTimer = 30; // 30 seconds timer
                            }
                            
                            this.monsters.splice(i, 1);
                            
                            // Bounce player
                            this.player.velocityY = -10;
                        } else {
                            // Player gets hit by monster
                            this.endGame(false);
                        }
                    }
                }
            }
            
            updateFireballs() {
                for (let i = this.fireballs.length - 1; i >= 0; i--) {
                    const fireball = this.fireballs[i];
                    fireball.update();
                    
                    // Remove fireballs that are off-screen or have traveled too far
                    if (fireball.x < this.camera.x - 50 || 
                        fireball.x > this.camera.x + this.canvas.width + 50 ||
                        fireball.distanceTraveled > fireball.maxDistance) {
                        this.fireballs.splice(i, 1);
                        continue;
                    }
                    
                    // Check collision with monsters
                    for (let j = this.monsters.length - 1; j >= 0; j--) {
                        const monster = this.monsters[j];
                        if (this.collides(fireball, monster)) {
                            // Defeat monster
                            this.score += 50;
                            this.createDustEffect(monster.x, monster.y);
                            
                            // Check if this is the BOI monster
                            if (monster.type === 'BOI') {
                                this.shouldRespawnBoi = true;
                                this.boiRespawnTimer = 30; // 30 seconds timer
                            }
                            
                            this.monsters.splice(j, 1);
                            this.fireballs.splice(i, 1);
                            break;
                        }
                    }
                }
            }
            
            checkBoiRespawn() {
                if (this.shouldRespawnBoi) {
                    this.boiRespawnTimer -= 1/60; // Assuming 60 FPS
                    
                    if (this.boiRespawnTimer <= 0) {
                        // Respawn BOI monster
                        this.monsters.push(new Monster(this, 3300, 290, 'BOI'));
                        this.shouldRespawnBoi = false;
                    }
                }
            }
            
            checkCheckpoints() {
                for (let i = 0; i < this.checkpoints.length; i++) {
                    const checkpoint = this.checkpoints[i];
                    
                    if (!checkpoint.passed && this.player.x > checkpoint.x) {
                        checkpoint.passed = true;
                        this.score += 200; // Bonus for reaching checkpoint
                        this.showCheckpointMessage(checkpoint.message);
                    }
                }
            }
            
            checkFlagpole() {
                if (this.player.x > this.flagpole.x) {
                    this.endGame(true);
                }
            }
            
            showCheckpointMessage(message) {
                this.checkpointMessage.textContent = message;
                this.checkpointMessage.style.display = 'block';
                
                // Hide message after 3 seconds
                setTimeout(() => {
                    this.checkpointMessage.style.display = 'none';
                }, 3000);
            }
            
            createDustEffect(x, y) {
                // Simple dust effect (would be replaced with actual animation in a full game)
                const dust = document.createElement('div');
                dust.style.position = 'absolute';
                dust.style.left = `${x - this.camera.x}px`;
                dust.style.top = `${y}px`;
                dust.style.width = '40px';
                dust.style.height = '40px';
                dust.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
                dust.style.borderRadius = '50%';
                dust.style.animation = 'dust 0.5s forwards';
                dust.style.zIndex = '5';
                
                document.getElementById('ui-layer').appendChild(dust);
                
                // Remove dust element after animation
                setTimeout(() => {
                    dust.remove();
                }, 500);
            }
            
            drawBackground() {
                // Sky
                this.ctx.fillStyle = '#87CEEB';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Office background
                // Window frames (far background)
                for (let i = 0; i < 8; i++) {
                    const windowX = (i * 200) - (this.camera.x * 0.2) % 1600; // Parallax effect
                    
                    this.ctx.fillStyle = '#E0E0E0';
                    this.ctx.fillRect(windowX, 50, 150, 150);
                    
                    this.ctx.strokeStyle = '#888';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(windowX, 50, 150, 150);
                    
                    // Window crossbars
                    this.ctx.beginPath();
                    this.ctx.moveTo(windowX, 125);
                    this.ctx.lineTo(windowX + 150, 125);
                    this.ctx.moveTo(windowX + 75, 50);
                    this.ctx.lineTo(windowX + 75, 200);
                    this.ctx.stroke();
                }
                
                // Office walls (mid background)
                this.ctx.fillStyle = '#F5F5F5';
                this.ctx.fillRect(0, 200, this.canvas.width, 250);
                
                // Decorative wall elements
                for (let i = 0; i < 10; i++) {
                    const elementX = (i * 250) - (this.camera.x * 0.5) % 2500;
                    
                    // Wall decor
                    this.ctx.fillStyle = '#DDD';
                    this.ctx.fillRect(elementX, 220, 120, 80);
                    
                    // Simple office poster/painting
                    this.ctx.strokeStyle = '#999';
                    this.ctx.strokeRect(elementX + 10, 230, 100, 60);
                }
            }
            
            renderPlatforms() {
                // Filter platforms that are on screen
                const visiblePlatforms = this.platforms.filter(platform => {
                    return platform.x + platform.width > this.camera.x && 
                           platform.x < this.camera.x + this.canvas.width;
                });
                
                // Draw platforms
                visiblePlatforms.forEach(platform => {
                    const adjustedX = platform.x - this.camera.x;
                    
                    if (platform.type === 'ground') {
                        // Draw ground
                        this.ctx.fillStyle = '#8B4513'; // Brown base
                        this.ctx.fillRect(adjustedX, platform.y, platform.width, platform.height);
                        
                        // Draw floor tiles
                        this.ctx.fillStyle = '#A0522D'; // Lighter brown tiles
                        for (let x = 0; x < platform.width; x += 40) {
                            for (let y = 0; y < platform.height; y += 20) {
                                if ((x + y) % 40 === 0) {
                                    this.ctx.fillRect(adjustedX + x, platform.y + y, 20, 10);
                                }
                            }
                        }
                    } else if (platform.type === 'desk') {
                        // Draw desk platform
                        this.ctx.fillStyle = '#8B4513'; // Brown
                        this.ctx.fillRect(adjustedX, platform.y, platform.width, platform.height);
                        
                        // Desk top
                        this.ctx.fillStyle = '#D2B48C'; // Tan
                        this.ctx.fillRect(adjustedX, platform.y, platform.width, 5);
                        
                        // Desk legs
                        this.ctx.fillStyle = '#5D4037'; // Dark brown
                        this.ctx.fillRect(adjustedX + 10, platform.y + 5, 8, platform.height - 5);
                        this.ctx.fillRect(adjustedX + platform.width - 18, platform.y + 5, 8, platform.height - 5);
                    } else if (platform.type === 'cabinet') {
                        // Draw filing cabinet
                        this.ctx.fillStyle = '#607D8B'; // Blue-gray
                        this.ctx.fillRect(adjustedX, platform.y, platform.width, platform.height);
                        
                        // Cabinet details
                        this.ctx.fillStyle = '#455A64'; // Darker blue-gray
                        this.ctx.fillRect(adjustedX + 5, platform.y + 5, platform.width - 10, 3);
                        this.ctx.fillRect(adjustedX + 5, platform.y + 12, platform.width - 10, 3);
                        
                        // Handle
                        this.ctx.fillStyle = '#CFD8DC'; // Light gray
                        this.ctx.fillRect(adjustedX + platform.width - 15, platform.y + 7, 5, 6);
                    }
                });
            }
            
            renderCheckpoints() {
                // Draw checkpoints
                this.checkpoints.forEach((checkpoint, index) => {
                    if (checkpoint.x > this.camera.x - 50 && checkpoint.x < this.camera.x + this.canvas.width + 50) {
                        const adjustedX = checkpoint.x - this.camera.x;
                        
                        // Draw checkpoint post
                        this.ctx.fillStyle = '#444';
                        this.ctx.fillRect(adjustedX - 5, 350, 10, 100);
                        
                        // Draw checkpoint flag
                        this.ctx.fillStyle = checkpoint.passed ? '#4CAF50' : '#FFC107';
                        this.ctx.beginPath();
                        this.ctx.moveTo(adjustedX + 5, 350);
                        this.ctx.lineTo(adjustedX + 5, 380);
                        this.ctx.lineTo(adjustedX + 30, 365);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Draw checkpoint number
                        this.ctx.fillStyle = '#FFF';
                        this.ctx.font = '14px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`${index + 1}`, adjustedX, 340);
                    }
                });
            }
            
            renderFlagpole() {
                if (this.flagpole.x > this.camera.x - 50 && this.flagpole.x < this.camera.x + this.canvas.width + 50) {
                    const adjustedX = this.flagpole.x - this.camera.x;
                    
                    // Draw pole
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(adjustedX, this.flagpole.y, 10, this.flagpole.height);
                    
                    // Draw base
                    this.ctx.fillStyle = '#555';
                    this.ctx.fillRect(adjustedX - 10, this.flagpole.y + this.flagpole.height - 10, 30, 10);
                    
                    // Draw flag
                    this.ctx.fillStyle = '#FF4081';
                    this.ctx.beginPath();
                    this.ctx.moveTo(adjustedX + 10, this.flagpole.y);
                    this.ctx.lineTo(adjustedX + 10, this.flagpole.y + 40);
                    this.ctx.lineTo(adjustedX + 40, this.flagpole.y + 20);
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // Draw finish text
                    this.ctx.fillStyle = '#FFF';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('FINISH', adjustedX + 25, this.flagpole.y + 60);
                }
            }
            
            renderMonsters() {
                // Filter monsters that are on screen
                const visibleMonsters = this.monsters.filter(monster => {
                    return monster.x + monster.width > this.camera.x && 
                           monster.x < this.camera.x + this.canvas.width;
                });
                
                // Draw monsters
                visibleMonsters.forEach(monster => {
                    monster.render();
                });
            }
            
            renderFireballs() {
                this.fireballs.forEach(fireball => {
                    fireball.render();
                });
            }
            
            updateUI() {
                // Update score display
                this.scoreDisplay.textContent = `Score: ${this.score}`;
                
                // Update timer display
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = Math.floor(this.timeElapsed % 60);
                this.timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            }
            
            endGame(victory) {
                if (this.gameOver) return;
                
                this.isRunning = false;
                this.gameOver = true;
                this.victory = victory;
                
                // Update final score with time bonus if victory
                if (victory) {
                    // Time bonus: faster = better
                    const timeBonus = Math.max(0, 3000 - Math.floor(this.timeElapsed) * 10);
                    this.score += timeBonus;
                }
                
                // Show game over screen
                this.finalScoreDisplay.textContent = `Your Score: ${this.score}`;
                
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = Math.floor(this.timeElapsed % 60);
                this.finalTimeDisplay.textContent = `Completion Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                this.gameOverScreen.style.display = 'block';
                this.leaderboard.style.display = 'block';
                
                // Cancel animation frame
                cancelAnimationFrame(this.animationFrameId);
            }
            
            saveScore() {
                const playerName = document.getElementById('player-name-input').value.trim() || 'Anonymous';
                
                // Get existing leaderboard
                let leaderboard = JSON.parse(localStorage.getItem('officeRunnerLeaderboard') || '[]');
                
                // Add new score
                leaderboard.push({
                    name: playerName,
                    score: this.score,
                    time: this.timeElapsed,
                    date: new Date().toLocaleDateString()
                });
                
                // Sort leaderboard (higher score is better)
                leaderboard.sort((a, b) => b.score - a.score);
                
                // Keep only top 10
                leaderboard = leaderboard.slice(0, 10);
                
                // Save back to localStorage
                localStorage.setItem('officeRunnerLeaderboard', JSON.stringify(leaderboard));
                
                // Refresh leaderboard display
                this.displayLeaderboard();
            }
            
            loadLeaderboard() {
                // Get leaderboard from localStorage
                const leaderboard = JSON.parse(localStorage.getItem('officeRunnerLeaderboard') || '[]');
                
                // Display leaderboard
                this.displayLeaderboard(leaderboard);
            }
            
            displayLeaderboard() {
                const leaderboard = JSON.parse(localStorage.getItem('officeRunnerLeaderboard') || '[]');
                const leaderboardBody = document.getElementById('leaderboard-body');
                
                // Clear existing entries
                leaderboardBody.innerHTML = '';
                
                // Add entries
                leaderboard.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    // Format time
                    const minutes = Math.floor(entry.time / 60);
                    const seconds = Math.floor(entry.time % 60);
                    const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    row.innerHTML = `
                        <td>${index + 1}</td>
                        <td>${entry.name}</td>
                        <td>${entry.score}</td>
                        <td>${timeFormatted}</td>
                        <td>${entry.date}</td>
                    `;
                    
                    leaderboardBody.appendChild(row);
                });
            }
            
            shareScore() {
                const text = `I scored ${this.score} points in Office Runner in ${Math.floor(this.timeElapsed / 60)}:${Math.floor(this.timeElapsed % 60).toString().padStart(2, '0')}! Can you beat my score?`;
                
                // Try to use clipboard API if available
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            alert('Score copied to clipboard! Share it with your friends!');
                        })
                        .catch(err => {
                            alert('Share this score: ' + text);
                        });
                } else {
                    alert('Share this score: ' + text);
                }
            }
            
            setupEventListeners() {
                // Keyboard events
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    // Prevent scrolling with arrow keys
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
                        e.preventDefault();
                    }
                    
                    // Handle fireball
                    if (e.code === 'Space' && this.isRunning && !this.gameOver) {
                        this.fireFireball();
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            fireFireball() {
                const currentTime = Date.now();
                
                // Limit fireball rate (one per second)
                if (currentTime - this.lastFireballTime < 1000) return;
                
                this.lastFireballTime = currentTime;
                
                // Create new fireball
                const fireball = new Fireball(
                    this,
                    this.player.x + (this.player.facingRight ? this.player.width : 0),
                    this.player.y + this.player.height / 3,
                    this.player.facingRight
                );
                
                this.fireballs.push(fireball);
            }
            
            collides(obj1, obj2) {
                return obj1.x < obj2.x + obj2.width &&
                       obj1.x + obj1.width > obj2.x &&
                       obj1.y < obj2.y + obj2.height &&
                       obj1.y + obj1.height > obj2.y;
            }
        }
        
        // Player Class
        class Player {
            constructor(game) {
                this.game = game;
                this.width = 30;
                this.height = 50;
                this.x = 50;
                this.y = 300;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5;
                this.jumpStrength = 14;
                this.gravity = 0.6;
                this.onGround = false;
                this.facingRight = true;
                
                // Animation properties
                this.frameCount = 0;
                this.animationFrame = 0;
                this.animationState = 'idle'; // idle, walking, jumping
            }
            
            update() {
                // Handle input
                this.handleInput();
                
                // Apply gravity
                this.velocityY += this.gravity;
                
                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Check boundaries
                this.checkBoundaries();
                
                // Check platform collisions
                this.checkPlatformCollisions();
                
                // Update animation
                this.updateAnimation();
            }
            
            handleInput() {
                // Reset horizontal velocity
                this.velocityX = 0;
                
                // Move left
                if (this.game.keys['ArrowLeft']) {
                    this.velocityX = -this.speed;
                    this.facingRight = false;
                    if (this.onGround) this.animationState = 'walking';
                }
                
                // Move right
                if (this.game.keys['ArrowRight']) {
                    this.velocityX = this.speed;
                    this.facingRight = true;
                    if (this.onGround) this.animationState = 'walking';
                }
                
                // Jump
                if (this.game.keys['ArrowUp'] && this.onGround) {
                    this.velocityY = -this.jumpStrength;
                    this.onGround = false;
                    this.animationState = 'jumping';
                }
                
                // If no horizontal movement and on ground, set to idle
                if (this.velocityX === 0 && this.onGround) {
                    this.animationState = 'idle';
                }
            }
            
            checkBoundaries() {
                // Left boundary
                if (this.x < 0) {
                    this.x = 0;
                }
                
                // Right boundary (level width)
                if (this.x + this.width > this.game.levelWidth) {
                    this.x = this.game.levelWidth - this.width;
                }
                
                // Bottom boundary (game over if fall off screen)
                if (this.y > this.game.canvas.height) {
                    this.game.endGame(false);
                }
            }
            
            checkPlatformCollisions() {
                this.onGround = false;
                
                for (const platform of this.game.platforms) {
                    // Check if player is colliding with the platform
                    if (
                        this.x < platform.x + platform.width &&
                        this.x + this.width > platform.x &&
                        this.y < platform.y + platform.height &&
                        this.y + this.height > platform.y
                    ) {
                        // Collision from above (landing on platform)
                        if (
                            this.velocityY > 0 &&
                            this.y + this.height - this.velocityY <= platform.y
                        ) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Collision from below (hitting platform from beneath)
                        else if (
                            this.velocityY < 0 &&
                            this.y - this.velocityY >= platform.y + platform.height
                        ) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                        // Collision from left
                        else if (
                            this.velocityX > 0 &&
                            this.x + this.width - this.velocityX <= platform.x
                        ) {
                            this.x = platform.x - this.width;
                        }
                        // Collision from right
                        else if (
                            this.velocityX < 0 &&
                            this.x - this.velocityX >= platform.x + platform.width
                        ) {
                            this.x = platform.x + platform.width;
                        }
                    }
                }
            }
            
            updateAnimation() {
                // Increment frame count
                this.frameCount++;
                
                // Update animation frame every 5 game frames
                if (this.frameCount % 5 === 0) {
                    // Reset if reached the end of frames
                    if (this.animationState === 'walking') {
                        this.animationFrame = (this.animationFrame + 1) % 4;
                    } else {
                        this.animationFrame = 0;
                    }
                }
            }
            
            render() {
                const ctx = this.game.ctx;
                const adjustedX = this.x - this.game.camera.x;
                
                // Draw AIM running man character using SVG-like drawing
                
                // Base color
                ctx.fillStyle = '#FFD700'; // Gold/Yellow
                
                // Body parts based on animation state
                if (this.animationState === 'idle') {
                    // Head
                    ctx.beginPath();
                    ctx.arc(adjustedX + (this.facingRight ? 20 : 10), this.y + 10, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.fillRect(adjustedX + 10, this.y + 20, 10, 20);
                    
                    // Arms
                    ctx.fillRect(adjustedX + (this.facingRight ? 20 : 0), this.y + 22, 10, 5);
                    
                    // Legs
                    ctx.fillRect(adjustedX + 5, this.y + 40, 5, 10);
                    ctx.fillRect(adjustedX + 20, this.y + 40, 5, 10);
                    
                } else if (this.animationState === 'walking') {
                    // Head
                    ctx.beginPath();
                    ctx.arc(adjustedX + (this.facingRight ? 20 : 10), this.y + 10, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.fillRect(adjustedX + 10, this.y + 20, 10, 20);
                    
                    // Arms - swing based on animation frame
                    const armOffset = [5, 10, 5, 0][this.animationFrame];
                    ctx.fillRect(
                        adjustedX + (this.facingRight ? 20 : 0),
                        this.y + 22 - armOffset,
                        10,
                        5
                    );
                    
                    // Legs - alternate based on animation frame
                    if (this.animationFrame === 0 || this.animationFrame === 2) {
                        ctx.fillRect(adjustedX + 5, this.y + 40, 5, 10);
                        ctx.fillRect(adjustedX + 20, this.y + 40 - 5, 5, 15);
                    } else {
                        ctx.fillRect(adjustedX + 5, this.y + 40 - 5, 5, 15);
                        ctx.fillRect(adjustedX + 20, this.y + 40, 5, 10);
                    }
                    
                } else if (this.animationState === 'jumping') {
                    // Head
                    ctx.beginPath();
                    ctx.arc(adjustedX + (this.facingRight ? 20 : 10), this.y + 10, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body - slightly curved for jump
                    ctx.fillRect(adjustedX + 10, this.y + 20, 10, 20);
                    
                    // Arms - up for jump
                    ctx.fillRect(
                        adjustedX + (this.facingRight ? 20 : 0),
                        this.y + 15,
                        10,
                        5
                    );
                    
                    // Legs - tucked for jump
                    ctx.fillRect(adjustedX + 8, this.y + 40, 5, 7);
                    ctx.fillRect(adjustedX + 17, this.y + 40, 5, 7);
                }
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(
                    adjustedX + (this.facingRight ? 23 : 7),
                    this.y + 8,
                    2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Smile
                ctx.beginPath();
                ctx.arc(
                    adjustedX + (this.facingRight ? 23 : 7),
                    this.y + 12,
                    5,
                    0,
                    Math.PI
                );
                ctx.stroke();
            }
        }
        
        // Monster Class
        class Monster {
            constructor(game, x, y, type) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = 30;
                this.height = 30;
                this.velocityX = 1 + Math.random(); // Random speed
                this.velocityY = 0;
                this.direction = Math.random() > 0.5 ? 1 : -1; // Random initial direction
                this.frameCount = 0;
                this.animationFrame = 0;
                
                // Different properties based on monster type
                switch(type) {
                    case 'DOGE':
                        this.color = '#F9A825'; // Golden
                        this.speed = 1.2;
                        break;
                    case 'Client':
                        this.color = '#E53935'; // Red
                        this.speed = 1.5;
                        break;
                    case 'Paper':
                        this.color = '#FFFFFF'; // White
                        this.speed = 1;
                        break;
                    case 'Mercedes':
                        this.color = '#607D8B'; // Blue-gray
                        this.speed = 1.8;
                        break;
                    case 'BOI':
                        this.color = '#9C27B0'; // Purple
                        this.speed = 2;
                        break;
                    default:
                        this.color = '#888';
                        this.speed = 1;
                }
                
                this.velocityX = this.speed * this.direction;
            }
            
            update() {
                // Apply gravity
                this.velocityY += 0.6;
                
                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // Platform collision check
                this.checkPlatformCollisions();
                
                // Edge check (turn around)
                this.checkEdges();
                
                // Update animation
                this.frameCount++;
                if (this.frameCount % 10 === 0) {
                    this.animationFrame = (this.animationFrame + 1) % 2;
                }
            }
            
            checkPlatformCollisions() {
                for (const platform of this.game.platforms) {
                    // Check if monster is colliding with the platform
                    if (
                        this.x < platform.x + platform.width &&
                        this.x + this.width > platform.x &&
                        this.y < platform.y + platform.height &&
                        this.y + this.height > platform.y
                    ) {
                        // Collision from above (landing on platform)
                        if (
                            this.velocityY > 0 &&
                            this.y + this.height - this.velocityY <= platform.y
                        ) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                        }
                        // Collision from sides (reverse direction)
                        else if (
                            (this.velocityX > 0 && this.x + this.width >= platform.x && this.x < platform.x) ||
                            (this.velocityX < 0 && this.x <= platform.x + platform.width && this.x + this.width > platform.x + platform.width)
                        ) {
                            this.direction *= -1;
                            this.velocityX = this.speed * this.direction;
                        }
                    }
                }
            }
            
            checkEdges() {
                // If close to falling off a platform, turn around
                let onPlatform = false;
                let nearEdge = true;
                
                for (const platform of this.game.platforms) {
                    // Check if monster is on this platform
                    if (
                        this.x + this.width > platform.x &&
                        this.x < platform.x + platform.width &&
                        Math.abs((this.y + this.height) - platform.y) < 5
                    ) {
                        onPlatform = true;
                        
                        // Check if about to walk off edge
                        if (
                            (this.velocityX > 0 && this.x + this.width + 20 < platform.x + platform.width) ||
                            (this.velocityX < 0 && this.x - 20 > platform.x)
                        ) {
                            nearEdge = false;
                        }
                    }
                }
                
                if (onPlatform && nearEdge) {
                    this.direction *= -1;
                    this.velocityX = this.speed * this.direction;
                }
            }
            
            render() {
                const ctx = this.game.ctx;
                const adjustedX = this.x - this.game.camera.x;
                
                // Draw different monsters based on type
                switch(this.type) {
                    case 'DOGE':
                        // DOGE crypto symbol
                        ctx.fillStyle = this.color;
                        
                        // Doge head
                        ctx.beginPath();
                        ctx.arc(adjustedX + 15, this.y + 15, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Ears
                        ctx.beginPath();
                        ctx.moveTo(adjustedX + 5, this.y + 5);
                        ctx.lineTo(adjustedX, this.y - 5);
                        ctx.lineTo(adjustedX + 10, this.y);
                        ctx.fill();
                        
                        ctx.beginPath();
                        ctx.moveTo(adjustedX + 25, this.y + 5);
                        ctx.lineTo(adjustedX + 30, this.y - 5);
                        ctx.lineTo(adjustedX + 20, this.y);
                        ctx.fill();
                        
                        // Face
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(adjustedX + 10, this.y + 12, 2, 0, Math.PI * 2); // Left eye
                        ctx.arc(adjustedX + 20, this.y + 12, 2, 0, Math.PI * 2); // Right eye
                        ctx.fill();
                        
                        // Mouth based on animation frame
                        if (this.animationFrame === 0) {
                            ctx.beginPath();
                            ctx.arc(adjustedX + 15, this.y + 20, 5, 0, Math.PI);
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            ctx.arc(adjustedX + 15, this.y + 18, 3, 0, Math.PI);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'Client':
                        // Angry Client (grumpy face)
                        ctx.fillStyle = this.color;
                        
                        // Head
                        ctx.beginPath();
                        ctx.arc(adjustedX + 15, this.y + 15, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Face
                        ctx.fillStyle = '#000';
                        
                        // Angry eyes
                        ctx.beginPath();
                        ctx.moveTo(adjustedX + 8, this.y + 10);
                        ctx.lineTo(adjustedX + 13, this.y + 12);
                        ctx.moveTo(adjustedX + 22, this.y + 10);
                        ctx.lineTo(adjustedX + 17, this.y + 12);
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Angry mouth based on animation frame
                        if (this.animationFrame === 0) {
                            ctx.beginPath();
                            ctx.arc(adjustedX + 15, this.y + 22, 5, Math.PI, Math.PI * 2);
                            ctx.stroke();
                        } else {
                            ctx.beginPath();
                            ctx.moveTo(adjustedX + 10, this.y + 22);
                            ctx.lineTo(adjustedX + 20, this.y + 22);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'Paper':
                        // Animated paper
                        ctx.fillStyle = this.color;
                        
                        // Paper sheet
                        ctx.fillRect(adjustedX + 5, this.y + 5, 20, 25);
                        
                        // Paper fold corner
                        ctx.beginPath();
                        ctx.moveTo(adjustedX + 25, this.y + 5);
                        ctx.lineTo(adjustedX + 25, this.y + 10);
                        ctx.lineTo(adjustedX + 20, this.y + 5);
                        ctx.closePath();
                        ctx.fillStyle = '#DDD';
                        ctx.fill();
                        
                        // Paper lines
                        ctx.strokeStyle = '#888';
                        ctx.beginPath();
                        for (let i = 0; i < 4; i++) {
                            const lineY = this.y + 10 + i * 5;
                            ctx.moveTo(adjustedX + 8, lineY);
                            ctx.lineTo(adjustedX + 22, lineY);
                        }
                        ctx.stroke();
                        
                        // Googly eyes based on animation
                        ctx.fillStyle = '#000';
                        const eyeOffsetX = this.animationFrame * 2;
                        ctx.beginPath();
                        ctx.arc(adjustedX + 12 + eyeOffsetX, this.y + 18, 2, 0, Math.PI * 2);
                        ctx.arc(adjustedX + 18 + eyeOffsetX, this.y + 18, 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'Mercedes':
                        // Mercedes logo-like
                        ctx.fillStyle = this.color;
                        
                        // Circle
                        ctx.beginPath();
                        ctx.arc(adjustedX + 15, this.y + 15, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Three-pointed star
                        ctx.fillStyle = '#FFF';
                        
                        // Star points with animation
                        const rotation = this.animationFrame * Math.PI / 12;
                        
                        // Center point
                        const centerX = adjustedX + 15;
                        const centerY = this.y + 15;
                        const radius = 13;
                        
                        // First point
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(rotation) * radius,
                            centerY + Math.sin(rotation) * radius
                        );
                        ctx.lineTo(
                            centerX + Math.cos(rotation + 0.3) * radius * 0.7,
                            centerY + Math.sin(rotation + 0.3) * radius * 0.7
                        );
                        ctx.fill();
                        
                        // Second point
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(rotation + Math.PI * 2/3) * radius,
                            centerY + Math.sin(rotation + Math.PI * 2/3) * radius
                        );
                        ctx.lineTo(
                            centerX + Math.cos(rotation + Math.PI * 2/3 + 0.3) * radius * 0.7,
                            centerY + Math.sin(rotation + Math.PI * 2/3 + 0.3) * radius * 0.7
                        );
                        ctx.fill();
                        
                        // Third point
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY);
                        ctx.lineTo(
                            centerX + Math.cos(rotation + Math.PI * 4/3) * radius,
                            centerY + Math.sin(rotation + Math.PI * 4/3) * radius
                        );
                        ctx.lineTo(
                            centerX + Math.cos(rotation + Math.PI * 4/3 + 0.3) * radius * 0.7,
                            centerY + Math.sin(rotation + Math.PI * 4/3 + 0.3) * radius * 0.7
                        );
                        ctx.fill();
                        break;
                        
                    case 'BOI':
                        // BOI block
                        ctx.fillStyle = this.color;
                        
                        // Block base
                        ctx.fillRect(adjustedX, this.y, 30, 30);
                        
                        // BOI text
                        ctx.fillStyle = '#FFF';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('BOI', adjustedX + 15, this.y + 20);
                        
                        // Pulsing effect
                        if (this.animationFrame === 1) {
                            ctx.strokeStyle = '#FFF';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(adjustedX, this.y, 30, 30);
                        }
                        break;
                        
                    default:
                        // Generic monster
                        ctx.fillStyle = this.color;
                        ctx.fillRect(adjustedX, this.y, 30, 30);
                }
